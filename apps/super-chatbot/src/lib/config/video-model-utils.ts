import { GenerationTypeEnum } from "@turbo-super/api";
import { getAvailableVideoModels } from "./superduperai";
import videoModelsConfig from "./video-models.json";
import type { VideoModel } from "@/lib/config/superduperai";

/**
 * Enhanced video model with metadata
 * AICODE-NOTE: Combines dynamic API data with static metadata
 */
export interface EnhancedVideoModel extends VideoModel {
  id?: string;
  description?: string;
  maxDuration?: number;
  maxResolution?: { width: number; height: number };
  supportedFrameRates?: number[];
  pricePerSecond?: number;
  workflowPath?: string;
  supportedAspectRatios?: string[];
  supportedQualities?: string[];
  category: "text_to_video" | "image_to_video" | "video_to_video";
  uiLabel: string;
  uiDescription: string;
  recommendedSettings: any;
  bestFor: string[];
  priceTier: "budget" | "standard" | "premium" | "luxury";
  requiresSourceImage: boolean;
  requiresSourceVideo: boolean;
}

/**
 * Get enhanced video models with metadata
 * AICODE-NOTE: Merges dynamic API data with static metadata
 */
export async function getEnhancedVideoModels(): Promise<EnhancedVideoModel[]> {
  try {
    // Get dynamic models from API
    const apiModels = await getAvailableVideoModels();

    // Enhance with metadata
    const enhancedModels: EnhancedVideoModel[] = apiModels.map((apiModel) => {
      const metadata =
        videoModelsConfig.model_metadata[
          apiModel.name as keyof typeof videoModelsConfig.model_metadata
        ];

      // Determine price tier
      let priceTier: "budget" | "standard" | "premium" | "luxury" = "standard";
      if (apiModel.params?.price_per_second <= 0.5) priceTier = "budget";
      else if (apiModel.params?.price_per_second <= 1.5) priceTier = "standard";
      else if (apiModel.params?.price_per_second <= 2.5) priceTier = "premium";
      else priceTier = "luxury";

      // Determine category from metadata or model name
      let category: "text_to_video" | "image_to_video" | "video_to_video" =
        "text_to_video";
      if (metadata?.category) {
        category = metadata.category as any;
      } else {
        // Fallback: detect from model name
        if (
          apiModel.name.includes("image-to-video") ||
          apiModel.name.includes("veo") ||
          apiModel.name.includes("kling")
        ) {
          category = "image_to_video";
        } else if (
          apiModel.name.includes("lip-sync") ||
          apiModel.name.includes("video-to-video")
        ) {
          category = "video_to_video";
        }
      }

      return {
        ...apiModel,
        category,
        uiLabel: metadata?.ui_label || apiModel.label || apiModel.name,
        uiDescription:
          metadata?.ui_description || `Generated by ${apiModel.source}`,
        recommendedSettings: metadata?.recommended_settings || {},
        bestFor: metadata?.best_for || [],
        priceTier,
        requiresSourceImage: category === "image_to_video",
        requiresSourceVideo: category === "video_to_video",
      };
    });

    return enhancedModels;
  } catch (error) {
    console.error("Error getting enhanced video models:", error);

    // Fallback to basic LTX model
    return [
      {
        name: "comfyui/ltx",
        label: "LTX Video",
        type: GenerationTypeEnum.TEXT_TO_VIDEO,
        source: "superduperai" as any,
        params: {
          price_per_second: 0.4,
          maxDuration: 30,
          maxResolution: { width: 1216, height: 704 },
          supportedFrameRates: [30],
          workflowPath: "LTX/default.json",
          supportedAspectRatios: ["16:9", "1:1", "9:16"],
          supportedQualities: ["hd"],
        },
        category: "text_to_video",
        uiLabel: "LTX Video",
        uiDescription: "Budget-friendly text-to-video generation",
        recommendedSettings:
          videoModelsConfig.model_metadata["comfyui/ltx"]
            ?.recommended_settings || {},
        bestFor: ["social_media", "quick_prototypes", "budget_projects"],
        priceTier: "budget",
        requiresSourceImage: false,
        requiresSourceVideo: false,
      },
    ];
  }
}

/**
 * Filter models by category
 */
export async function getModelsByCategory(
  category: "text_to_video" | "image_to_video" | "video_to_video"
): Promise<EnhancedVideoModel[]> {
  const models = await getEnhancedVideoModels();
  return models.filter((model) => model.category === category);
}

/**
 * Filter models by price tier
 */
export async function getModelsByPriceTier(
  tier: "budget" | "standard" | "premium" | "luxury"
): Promise<EnhancedVideoModel[]> {
  const models = await getEnhancedVideoModels();
  return models.filter((model) => model.priceTier === tier);
}

/**
 * Get recommended models for a specific use case
 */
export async function getRecommendedModels(
  useCase: string
): Promise<EnhancedVideoModel[]> {
  const models = await getEnhancedVideoModels();
  return models.filter((model) => model.bestFor.includes(useCase));
}

/**
 * Get model by ID with metadata
 */
export async function getEnhancedModelById(
  modelId: string
): Promise<EnhancedVideoModel | null> {
  const models = await getEnhancedVideoModels();
  return models.find((model) => model.name === modelId) || null;
}

/**
 * Get UI presets from config
 */
export function getUIPresets() {
  return videoModelsConfig.ui_presets;
}

/**
 * Get model categories info
 */
export function getModelCategories() {
  return videoModelsConfig.model_categories;
}

/**
 * Get pricing tiers info
 */
export function getPricingTiers() {
  return videoModelsConfig.pricing_tiers;
}
