import { tool } from "ai";
import { z } from 'zod/v3';
import type { MediaOption } from "@/lib/types/media-settings";
import { getImageGenerationConfig } from "@/lib/config/media-settings-factory";
import {
  checkBalanceBeforeArtifact,
  getOperationDisplayName,
} from "@/lib/utils/ai-tools-balance";
import type { Session } from "next-auth";
import { analyzeImageContext } from "@/lib/ai/context";

interface CreateImageDocumentParams {
  createDocument: any;
  session?: Session | null;
  defaultSourceImageUrl?: string | undefined;
  chatId?: string;
  userMessage?: string;
  currentAttachments?: any[];
}

export const configureImageGeneration = (params?: CreateImageDocumentParams) =>
  tool({
    description:
      "Configure image generation settings or generate an image directly if prompt is provided. Supports text-to-image by default, and image-to-image when a sourceImageUrl is provided. When triggered, creates an image artifact that shows generation progress in real-time.",
    inputSchema: z.object({
      prompt: z
        .string()
        .optional()
        .describe(
          "Detailed description of the image to generate. If provided, will immediately create image artifact and start generation"
        ),
      sourceImageUrl: z
        .string()
        .url()
        .optional()
        .describe(
          "Optional source image URL for image-to-image generation (e.g., when the user uploaded an image in chat). If provided, the system will run image-to-image."
        ),
      style: z
        .string()
        .optional()
        .describe(
          'Style of the image. Supports many formats: "realistic", "cinematic", "anime", "cartoon", "sketch", "painting", "steampunk", "fantasy", "sci-fi", "horror", "minimalist", "abstract", "portrait", "landscape", and many more available styles'
        ),
      resolution: z
        .string()
        .optional()
        .describe(
          'Image resolution. Accepts various formats: "1920x1080", "1920√ó1080", "1920 x 1080", "full hd", "fhd", "1080p", "square", "vertical", "horizontal", etc.'
        ),
      shotSize: z
        .string()
        .optional()
        .describe(
          'Shot size/camera angle. Accepts: "close-up", "medium-shot", "long-shot", "extreme-close-up", "portrait", "two-shot", etc.'
        ),
      model: z
        .string()
        .optional()
        .describe(
          'AI model to use. Models are loaded dynamically from SuperDuperAI API. Use model name like "FLUX" or full model ID.'
        ),
      seed: z.number().optional().describe("Seed for reproducible results"),
      batchSize: z
        .number()
        .min(1)
        .max(3)
        .optional()
        .describe(
          "Number of images to generate simultaneously (1-3). Higher batch sizes generate multiple variations at once."
        ),
    }),
    execute: async ({
      prompt,
      sourceImageUrl,
      style,
      resolution,
      shotSize,
      model,
      seed,
      batchSize,
    }) => {
      console.log("üîß configureImageGeneration called with:", {
        prompt,
        style,
        resolution,
        shotSize,
        model,
        seed,
        batchSize,
      });

      // AICODE-NOTE: Use new factory to get configuration with OpenAPI models
      console.log("üñºÔ∏è Loading image configuration from OpenAPI factory...");
      const config = await getImageGenerationConfig();

      console.log("üñºÔ∏è ‚úÖ Loaded image config:", {
        modelsCount: config.availableModels.length,
        resolutionsCount: config.availableResolutions.length,
        stylesCount: config.availableStyles.length,
      });

      // If no prompt provided, return configuration panel
      if (!prompt) {
        console.log(
          "üîß No prompt provided, returning image configuration panel"
        );
        return config;
      }

      console.log("üîß ‚úÖ PROMPT PROVIDED, CREATING IMAGE DOCUMENT:", prompt);

      if (!params?.createDocument) {
        console.log(
          "üîß ‚ùå createDocument not available, returning basic config"
        );
        return config;
      }

      // Check style for quality multipliers
      const multipliers: string[] = [];
      if (style?.includes("high-quality")) multipliers.push("high-quality");
      if (style?.includes("ultra-quality")) multipliers.push("ultra-quality");

      try {
        // Find the selected options or use defaults from factory
        const selectedResolution = resolution
          ? config.availableResolutions.find((r) => r.label === resolution) ||
            config.defaultSettings.resolution
          : config.defaultSettings.resolution;

        let selectedStyle: MediaOption = config.defaultSettings.style;
        if (style) {
          const foundStyle = findStyle(style, config.availableStyles);
          if (foundStyle) {
            selectedStyle = foundStyle;
            console.log(
              "üîß ‚úÖ STYLE MATCHED:",
              style,
              "->",
              selectedStyle.label
            );
          } else {
            console.log(
              "üîß ‚ö†Ô∏è STYLE NOT FOUND:",
              style,
              "using default:",
              selectedStyle.label
            );
          }
        }

        const selectedShotSize = shotSize
          ? config.availableShotSizes.find(
              (s) => s.label === shotSize || s.id === shotSize
            ) || config.defaultSettings.shotSize
          : config.defaultSettings.shotSize;

        const selectedModel = model
          ? config.availableModels.find(
              (m) => m.name === model || (m as any).id === model
            ) || config.defaultSettings.model
          : config.defaultSettings.model;

        // –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—É—é —Å–∏—Å—Ç–µ–º—É –∞–Ω–∞–ª–∏–∑–∞ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
        let normalizedSourceUrl = sourceImageUrl;

        console.log("üîç configureImageGeneration sourceImageUrl resolution:", {
          sourceImageUrl,
          defaultSourceImageUrl: params?.defaultSourceImageUrl,
          chatId: params?.chatId,
          userMessage: params?.userMessage,
        });

        // –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç 1: defaultSourceImageUrl (legacy –ø–æ–¥–¥–µ—Ä–∂–∫–∞)
        if (
          params?.defaultSourceImageUrl &&
          /^https?:\/\//.test(params.defaultSourceImageUrl)
        ) {
          console.log(
            "üîç Using defaultSourceImageUrl from legacy context analysis:",
            params.defaultSourceImageUrl
          );
          normalizedSourceUrl = params.defaultSourceImageUrl;
        }
        // –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç 2: –Ω–æ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞ –∞–Ω–∞–ª–∏–∑–∞ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
        else if (params?.chatId && params?.userMessage) {
          try {
            console.log("üîç Analyzing image context with new system...");
            const contextResult = await analyzeImageContext(
              params.userMessage,
              params.chatId,
              params.currentAttachments,
              params.session?.user?.id
            );

            console.log("üîç Context analysis result:", contextResult);

            if (contextResult.sourceUrl && contextResult.confidence !== "low") {
              console.log(
                "üîç Using sourceUrl from new context analysis:",
                contextResult.sourceUrl,
                "confidence:",
                contextResult.confidence
              );
              normalizedSourceUrl = contextResult.sourceUrl;
            }
          } catch (error) {
            console.warn("üîç Error in context analysis, falling back:", error);
          }
        }
        // –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç 3: AI-provided sourceImageUrl
        else if (
          normalizedSourceUrl &&
          /^https?:\/\//.test(normalizedSourceUrl) &&
          !normalizedSourceUrl.startsWith("attachment://")
        ) {
          console.log(
            "üîç Using AI-provided sourceImageUrl:",
            normalizedSourceUrl
          );
        }
        // Fallback: text-to-image
        else {
          console.log(
            "üîç No valid source image URL available, will be text-to-image"
          );
          normalizedSourceUrl = undefined;
        }

        // Determine operation type and check balance
        const operationType = normalizedSourceUrl
          ? "image-to-image"
          : "text-to-image";

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –±—ã–ª –ª–∏ –Ω–∞–π–¥–µ–Ω –ø–æ–¥—Ö–æ–¥—è—â–∏–π –∏—Å—Ç–æ—á–Ω–∏–∫ –¥–ª—è —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–æ–≥–æ –ø–æ–∏—Å–∫–∞
        if (
          params?.userMessage &&
          normalizedSourceUrl &&
          operationType === "image-to-image"
        ) {
          // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å–æ–¥–µ—Ä–∂–∏—Ç –ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –∑–∞–ø—Ä–æ—Å –Ω–∞ –ø–æ–∏—Å–∫ –ø–æ —Å–æ–¥–µ—Ä–∂–∏–º–æ–º—É
          const semanticSearchPatterns = [
            /(–∫–∞—Ä—Ç–∏–Ω–∫[–∞-—è]+\s+—Å\s+|–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ\s+—Å\s+|—Ñ–æ—Ç–æ\s+—Å\s+|image\s+with\s+|picture\s+with\s+|photo\s+with\s+)/i,
            /(–∫–∞—Ä—Ç–∏–Ω–∫[–∞-—è]+\s+–≥–¥–µ\s+–µ—Å—Ç—å|–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ\s+–≥–¥–µ\s+–µ—Å—Ç—å|—Ñ–æ—Ç–æ\s+–≥–¥–µ\s+–µ—Å—Ç—å|image\s+that\s+has|picture\s+that\s+contains|photo\s+that\s+shows)/i,
          ];

          const hasSemanticSearchRequest = semanticSearchPatterns.some(
            (pattern) => pattern.test(params.userMessage || "")
          );

          if (hasSemanticSearchRequest) {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –±—ã–ª –ª–∏ –Ω–∞–π–¥–µ–Ω –ø–æ–¥—Ö–æ–¥—è—â–∏–π –∏—Å—Ç–æ—á–Ω–∏–∫ —á–µ—Ä–µ–∑ —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫
            // –ï—Å–ª–∏ –∏—Å—Ç–æ—á–Ω–∏–∫ –±—ã–ª –Ω–∞–π–¥–µ–Ω —á–µ—Ä–µ–∑ fallback (–ø–æ—Å–ª–µ–¥–Ω–µ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ), —ç—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª
            const isFallbackSource =
              params.defaultSourceImageUrl === normalizedSourceUrl;

            console.log("üîç Fallback check:", {
              normalizedSourceUrl,
              defaultSourceImageUrl: params.defaultSourceImageUrl,
              isFallbackSource,
              hasSemanticSearchRequest,
            });

            if (isFallbackSource) {
              console.log(
                "üîç Semantic search failed, providing helpful message instead of balance error"
              );
              return {
                error: "semantic_search_failed",
                message:
                  "–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —è –Ω–µ —Å–º–æ–≥ –Ω–∞–π—Ç–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å –Ω—É–∂–Ω—ã–º —Å–æ–¥–µ—Ä–∂–∏–º—ã–º –≤ –∏—Å—Ç–æ—Ä–∏–∏ —á–∞—Ç–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ:\n\n‚Ä¢ –ó–∞–≥—Ä—É–∑–∏—Ç—å –Ω–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å –Ω—É–∂–Ω—ã–º —Å–æ–¥–µ—Ä–∂–∏–º—ã–º\n‚Ä¢ –û–ø–∏—Å–∞—Ç—å —Å—Ü–µ–Ω—É –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è\n‚Ä¢ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –±–æ–ª–µ–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ (–Ω–∞–ø—Ä–∏–º–µ—Ä, '–ø–µ—Ä–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ' –∏–ª–∏ '–ø–æ—Å–ª–µ–¥–Ω–µ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ')",
                suggestions: [
                  "–ó–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å –ª—É–Ω–æ–π",
                  "–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å –ª—É–Ω–æ–π",
                  "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–æ—Å–ª–µ–¥–Ω–µ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ",
                  "–û–ø–∏—Å–∞—Ç—å —Å—Ü–µ–Ω—É –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è",
                ],
              };
            }
          }
        }

        const balanceCheck = await checkBalanceBeforeArtifact(
          params.session || null,
          "image-generation",
          operationType,
          multipliers,
          getOperationDisplayName(operationType)
        );

        if (!balanceCheck.valid) {
          console.log("üîß ‚ùå INSUFFICIENT BALANCE, NOT CREATING ARTIFACT");
          return {
            error:
              balanceCheck.userMessage ||
              "–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è",
            balanceError: true,
            requiredCredits: balanceCheck.cost,
          };
        }

        // Create the image document with all parameters
        const imageParams = {
          prompt,
          style: selectedStyle,
          resolution: selectedResolution,
          shotSize: selectedShotSize,
          model: selectedModel,
          seed: seed || undefined,
          batchSize: batchSize || 1,
          ...(normalizedSourceUrl
            ? { sourceImageUrl: normalizedSourceUrl }
            : {}),
        };

        console.log("üîß ‚úÖ CREATING IMAGE DOCUMENT WITH PARAMS:", imageParams);
        console.log("üîç Final sourceImageUrl used:", normalizedSourceUrl);

        try {
          // AICODE-NOTE: For now we pass params as JSON in title for backward compatibility
          // TODO: Refactor to use proper parameter passing mechanism
          const result = await params.createDocument.execute({
            title: JSON.stringify(imageParams),
            kind: "image",
          });

          console.log("üîß ‚úÖ CREATE DOCUMENT RESULT:", result);

          return {
            ...result,
            message: `I'm creating ${operationType.replace("-", " ")} with description: "${prompt}". Using model "${selectedModel.name}" with ${selectedResolution.label} resolution. Artifact created and generation started.`,
          };
        } catch (error) {
          console.error("üîß ‚ùå CREATE DOCUMENT ERROR:", error);
          throw error;
        }
      } catch (error: any) {
        console.error("üîß ‚ùå ERROR CREATING IMAGE DOCUMENT:", error);
        return {
          error: `Failed to create image document: ${error.message}`,
          fallbackConfig: config,
        };
      }
    },
  });

// Helper function to find style (kept for backward compatibility)
export function findStyle(
  styleName: string,
  availableStyles: MediaOption[]
): MediaOption | null {
  const normalizedStyleName = styleName.toLowerCase().trim();

  // Direct match by label or id
  let foundStyle = availableStyles.find(
    (style) =>
      style.label.toLowerCase() === normalizedStyleName ||
      style.id.toLowerCase() === normalizedStyleName
  );

  if (foundStyle) return foundStyle;

  // Partial match
  foundStyle = availableStyles.find(
    (style) =>
      style.label.toLowerCase().includes(normalizedStyleName) ||
      style.id.toLowerCase().includes(normalizedStyleName) ||
      normalizedStyleName.includes(style.label.toLowerCase()) ||
      normalizedStyleName.includes(style.id.toLowerCase())
  );

  return foundStyle || null;
}
