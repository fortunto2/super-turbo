import { tool } from 'ai';
import { z } from 'zod';
import { contextManager } from '@/lib/ai/context';

export const findMediaInChat = tool({
  description: `Search for media (images, videos, audio) in current chat history.

Use this tool when user references media like:
- "this image", "that video", "the picture"
- "first/last/previous image"
- "uploaded image", "generated video"
- "image with moon", "picture of cat"

Returns list of media with URLs, IDs, prompts, and creation timestamps.`,

  inputSchema: z.object({
    chatId: z.string().describe('Current chat ID'),
    mediaType: z
      .enum(['image', 'video', 'audio', 'any'])
      .describe('Type of media to search for'),
    query: z
      .string()
      .optional()
      .describe(
        "Search query: 'last uploaded', 'with moon', 'generated by assistant', 'first image', etc.",
      ),
    limit: z
      .number()
      .optional()
      .default(5)
      .describe('Maximum results to return (max: 20)'),
    role: z
      .enum(['user', 'assistant', 'any'])
      .optional()
      .describe(
        'Filter by who created the media: user-uploaded or assistant-generated',
      ),
  }),

  execute: async ({ chatId, mediaType, query, limit = 5, role }) => {
    try {
      console.log(
        `🔍 [findMediaInChat] Searching for ${mediaType} in chat ${chatId}`,
        { query, limit, role },
      );

      // 1. Get all media from chat
      const chatMedia = await contextManager.getChatMedia(chatId);

      if (chatMedia.length === 0) {
        return {
          success: true,
          found: 0,
          media: [],
          message: 'No media found in this chat',
          suggestion:
            'You can generate media first or ask user to upload files.',
        };
      }

      // 2. Filter by type
      let filtered =
        mediaType === 'any'
          ? chatMedia
          : chatMedia.filter((m) => m.mediaType === mediaType);

      if (filtered.length === 0) {
        return {
          success: true,
          found: 0,
          media: [],
          message: `No ${mediaType} files found in this chat`,
          suggestion: `Try generating ${mediaType} or ask user to upload.`,
        };
      }

      // 3. Filter by role if specified
      if (role && role !== 'any') {
        filtered = filtered.filter((m) => m.role === role);
      }

      // 4. Apply query-based search if provided
      if (query) {
        // Use simple keyword matching
        const queryLower = query.toLowerCase();
        const keywords = queryLower.split(/\s+/).filter((w) => w.length > 2);

        // Filter by keywords in prompt
        if (keywords.length > 0) {
          const scored = filtered.map((m) => {
            const prompt = (m.prompt || '').toLowerCase();
            const score = keywords.reduce(
              (acc, kw) => acc + (prompt.includes(kw) ? 1 : 0),
              0,
            );
            return { media: m, score };
          });

          // Sort by score, keep only matches
          const matches = scored
            .filter((s) => s.score > 0)
            .sort((a, b) => b.score - a.score);

          if (matches.length > 0) {
            filtered = matches.map((m) => m.media);
          }
        }

        // Handle position queries (first, second, last)
        if (/first|1st/i.test(queryLower) && filtered[0]) {
          filtered = [filtered[0]];
        } else if (/second|2nd/i.test(queryLower) && filtered[1]) {
          filtered = [filtered[1]];
        } else if (/last|latest/i.test(queryLower)) {
          const lastItem = filtered[filtered.length - 1];
          if (lastItem) {
            filtered = [lastItem];
          }
        }

        // Handle role queries in search string
        if (/uploaded|user|my/i.test(queryLower)) {
          filtered = filtered.filter((m) => m.role === 'user');
        } else if (/generated|assistant|created/i.test(queryLower)) {
          filtered = filtered.filter((m) => m.role === 'assistant');
        }
      }

      // 5. Sort by timestamp (most recent first)
      filtered.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());

      // 6. Limit results (cap at 20)
      const maxLimit = Math.min(limit, 20);
      filtered = filtered.slice(0, maxLimit);

      // 7. Format response for LLM
      return {
        success: true,
        found: filtered.length,
        media: filtered.map((m) => ({
          id: m.id || 'unknown',
          url: m.url,
          type: m.mediaType,
          role: m.role,
          prompt: m.prompt || 'No prompt',
          timestamp: m.timestamp.toISOString(),
          messageIndex: m.messageIndex,
        })),
        message:
          filtered.length > 0
            ? `Found ${filtered.length} ${mediaType === 'any' ? 'media file' : mediaType}${filtered.length > 1 ? 's' : ''} matching "${query || 'your search'}"`
            : `No ${mediaType} files found matching "${query || 'your search'}"`,
        suggestion:
          filtered.length === 0
            ? 'Try a different search query or ask user to upload/generate media first'
            : `You can now use these media URLs in generate* tools via sourceImageUrl/sourceVideoUrl parameter`,
      };
    } catch (error: any) {
      console.error('[findMediaInChat] Error:', error);
      return {
        success: false,
        found: 0,
        media: [],
        error: error.message || 'Failed to search for media',
      };
    }
  },
});
